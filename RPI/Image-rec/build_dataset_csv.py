import iou as iou_fn
import config
from bs4 import BeautifulSoup
from imutils import paths
import cv2
import os
import pandas as pd

# grab all image paths in the input images directory
imagePaths = list(paths.list_images(config.ORIG_IMAGES))

# initialize total number of positive and negative images currently in disk
totalPositive = 1000
totalNegative = 5700

# loop over image paths
for (i, imagePath) in enumerate(imagePaths):
	# progress report
	print("Processing image {}/{}...".format(i + 1, len(imagePaths)))

	# extract filename from file path and derive path to  CSV annotation file
	filename = imagePath.split(os.path.sep)[-1]
	annotPath = pd.read_csv(config.ORIG_BASE_PATH+"_labels.csv")
	gtBoxes = []
	filename2 = annotPath['filename'] == filename
	annotPath = annotPath[filename2]
	xMin = int(annotPath['xmin'].values[0])
	yMin = int(annotPath['ymin'].values[0])
	xMax = int(annotPath['xmax'].values[0])
	yMax = int(annotPath['ymax'].values[0])
	w = int(annotPath['width'].values[0])
	h = int(annotPath['height'].values[0])
	image_class = str(annotPath['class'].values[0])
	# outside the boundaries of the image
	xMin = max(0, xMin)
	yMin = max(0, yMin)
	xMax = min(w, xMax)
	yMax = min(h, yMax)

	# update ground-truth bounding boxes list
	gtBoxes.append((xMin, yMin, xMax, yMax))

	# load input image from disk
	image = cv2.imread(imagePath)

	# run selective search
	ss = cv2.ximgproc.segmentation.createSelectiveSearchSegmentation()
	ss.setBaseImage(image)
	ss.switchToSelectiveSearchFast()
	rects = ss.process()
	proposedRects= []

	# loop over the rectangles generated by selective search
	for (x, y, w, h) in rects:
		proposedRects.append((x, y, x + w, y + h))

	# to count number of positive and negative ROIs saved
	positiveROIs = 0
	negativeROIs = 0

	# loop over max number of region proposals
	for proposedRect in proposedRects[:config.MAX_PROPOSALS]:
		# unpack the proposed rectangle bounding box
		(propStartX, propStartY, propEndX, propEndY) = proposedRect

		# loop over the ground-truth bounding boxes
		for gtBox in gtBoxes:
			iou = iou_fn.compute_iou(gtBox, proposedRect)
			(gtStartX, gtStartY, gtEndX, gtEndY) = gtBox

			roi = None
			outputPath = None

			if iou > 0.7 and positiveROIs <= config.MAX_POSITIVE:
				# extract ROI and derive positive output path
				roi = image[propStartY:propEndY, propStartX:propEndX]
				filename = "{}.png".format(totalPositive)
				outputPath = os.path.sep.join([config.POSITVE_PATH, filename])

				# increment positive counters
				positiveROIs += 1
				totalPositive += 1

			fullOverlap = propStartX >= gtStartX
			fullOverlap = fullOverlap and propStartY >= gtStartY
			fullOverlap = fullOverlap and propEndX <= gtEndX
			fullOverlap = fullOverlap and propEndY <= gtEndY

			if not fullOverlap and iou < 0.05 and \
				negativeROIs <= config.MAX_NEGATIVE:
				# extract ROI and derive negative output path
				roi = image[propStartY:propEndY, propStartX:propEndX]
				filename = "{}.png".format(totalNegative)
				outputPath = os.path.sep.join([config.NEGATIVE_PATH,
					filename])

				# increment negative counters
				negativeROIs += 1
				totalNegative += 1

			if roi is not None and outputPath is not None:
				# resize the ROI to the input dimensions of the CNN
				roi = cv2.resize(roi, config.INPUT_DIMS,
					interpolation=cv2.INTER_CUBIC)
				cv2.imwrite(outputPath, roi)